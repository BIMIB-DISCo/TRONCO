#### get.bootstapped.scores.R
####
#### TRONCO: a tool for TRanslational ONCOlogy
####
#### See the files COPYING and LICENSE for copyright and licensing
#### information.


#compute a robust estimation of the scores using rejection sampling bootstrap
#INPUT:
#dataset: a valid dataset
#nboot: number of bootstrap resampling to be performed
#adj.matrix: adjacency matrix of the initially valid edges
#RETURN:
#scores: list structure with the scores and the data generated by bootstrap
"get.bootstapped.scores" <-
function(dataset, nboot, adj.matrix) {
    #structures to save the distributions generated by the bootstrapped datasets
    marginal.probs.distributions <- array(list(-1), c(ncol(dataset),1));
    joint.probs.distributions <- array(list(-1), c(ncol(dataset),ncol(dataset)));
    prima.facie.model.distributions <- array(list(-1), c(ncol(dataset),ncol(dataset)));
    prima.facie.null.distributions <- array(list(-1), c(ncol(dataset),ncol(dataset)));
    #structures to save the number of performed valid (not rejected) sampling
    sampled.marginal.probs.distributions <- array(0, dim=c(ncol(dataset),1));
    sampled.joint.probs.distributions <- array(0, dim=c(ncol(dataset),ncol(dataset)));
    sampled.prima.facie.distributions <- array(0, dim=c(ncol(dataset),ncol(dataset)));
    #set not to sample for the invalid edges
	for(i in 1:nrow(adj.matrix)) {
	    for(j in 1:ncol(adj.matrix)) {
            if(adj.matrix[i,j]==0) {
                sampled.prima.facie.distributions[i,j] = nboot;
            }
        }
    }
    #perform bootstrap estimation based on a number of bootstrapped (>= nboot) datasets
    while(min(sampled.prima.facie.distributions)<nboot) {
        #define the dataset to be used in this iteration and compute the scores on it
        sampled.data = dataset[sample(1:nrow(dataset),size=nrow(dataset),replace=TRUE),];
        #compute the scores on the sampled data
        curr.scores = get.dag.scores(sampled.data,adj.matrix);
        curr.marginal.probs = curr.scores$marginal.probs;
        curr.joint.probs = curr.scores$joint.probs;
        curr.prima.facie.model = curr.scores$prima.facie.model;
        curr.prima.facie.null = curr.scores$prima.facie.null;
        #save the (valid) scores for each edge
        for(i in 1:nrow(curr.prima.facie.model)) {
            #get the marginal probabilities from the sampled data
            if(sampled.marginal.probs.distributions[i,1]==0) {
                sampled.marginal.probs.distributions[i,1] = 1;
                marginal.probs.distributions[i,1] = curr.marginal.probs[i,1];
            }
            else {
                marginal.probs.distributions[i,1] = list(c(unlist(marginal.probs.distributions[i,1]),curr.marginal.probs[i,1]));
            }
            for(j in i:ncol(curr.prima.facie.model)) {
                #get the joint probs from the sampled data
                if(sampled.joint.probs.distributions[i,j]==0) {
                    sampled.joint.probs.distributions[i,j] = 1;
                    joint.probs.distributions[i,j] = curr.joint.probs[i,j];
                    if(i!=j) {
                        joint.probs.distributions[j,i] = joint.probs.distributions[i,j];
                    }
                }
                else {
                    joint.probs.distributions[i,j] = list(c(unlist(joint.probs.distributions[i,j]),curr.joint.probs[i,j]));
                    if(i!=j) {
                        joint.probs.distributions[j,i] = joint.probs.distributions[i,j];
                    }
                }
                #get the prima facie estimations from the sampled data
                if(curr.prima.facie.model[i,j]!=-1) {
                    #count the valid values per edge
                    sampled.prima.facie.distributions[i,j] = sampled.prima.facie.distributions[i,j] + 1;
                    sampled.prima.facie.distributions[j,i] = sampled.prima.facie.distributions[j,i] + 1;
                    #save the scores
                    if(sampled.prima.facie.distributions[i,j]==1) {
                        #scores for i --> j
                        prima.facie.model.distributions[i,j] = list(curr.prima.facie.model[i,j]);
                        prima.facie.null.distributions[i,j] = list(curr.prima.facie.null[i,j]);
                        #scores for j --> i
                        prima.facie.model.distributions[j,i] = list(curr.prima.facie.model[j,i]);
                        prima.facie.null.distributions[j,i] = list(curr.prima.facie.null[j,i]);
                    }
                    else {
                        #scores for i --> j
                        prima.facie.model.distributions[i,j] = list(c(unlist(prima.facie.model.distributions[i,j]),curr.prima.facie.model[i,j]));
                        prima.facie.null.distributions[i,j] = list(c(unlist(prima.facie.null.distributions[i,j]),curr.prima.facie.null[i,j]));
                        #scores for j --> i
                        prima.facie.model.distributions[j,i] = list(c(unlist(prima.facie.model.distributions[j,i]),curr.prima.facie.model[j,i]));
                        prima.facie.null.distributions[j,i] = list(c(unlist(prima.facie.null.distributions[j,i]),curr.prima.facie.null[j,i]));
                    }
                }
            }
        }
    }
    scores <- list(marginal.probs.distributions=marginal.probs.distributions,joint.probs.distributions=joint.probs.distributions,prima.facie.model.distributions=prima.facie.model.distributions,prima.facie.null.distributions=prima.facie.null.distributions);
    return(scores);
}

#### end of file -- get.bootstapped.scores.R
